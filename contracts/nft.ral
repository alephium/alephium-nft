// Who can change the metadata of this NFT? Maybe it should just be fixed
// when it is created, to reduce complexity
// Right now only 1 token is supported
TxContract NFT(
    mut owner: Address,
    name: ByteVec,
    symbol: ByteVec,
    uri: ByteVec,                 // name; description; image
    collectionAddress: Address    // The collection address, 0 when no collection
) {

    event NFTOwnerUpdated(
      previousOwner: Address,
      newOwner: Address
    )

    event NFTWithdrawn(
      owner: Address
    )

    event NFTDeposited(
      owner: Address
    )

    event NFTBurnt(
      owner: Address
    )

    pub fn getMetadata() -> (ByteVec, ByteVec, ByteVec, Address) {
        return name, symbol, uri, collectionAddress
    }

    pub fn getOwner() -> (Address) {
        return owner
    }

    @use(contractAssets = true)
    pub fn updateOwner(newOwner: Address) -> () {
        assert!(txCallerSize!() == 1)
        assert!(txCaller!(0) == owner || callerAddress!() == owner)

        // Token needs to be owned by the contract when owner is changed
        assert!(tokenRemaining!(selfAddress!(), selfContractId!()) == 1)

        emit NFTOwnerUpdated(owner, newOwner)
        owner = newOwner
    }

    @use(approvedAssets=true, contractAssets = true)
    pub fn deposit() -> () {
        checkCallerIsOwner()

        emit NFTDeposited(owner)

        transferTokenToSelf!(owner, selfContractId!(), 1)
    }

    @use(approvedAssets=true, contractAssets = true)
    pub fn withdraw() -> () {
        checkCallerIsOwner()

        emit NFTWithdrawn(owner)

        transferTokenFromSelf!(owner, selfContractId!(), 1)
    }

    @use(approvedAssets = true, contractAssets = true)
    pub fn burn() -> () {
        checkCallerIsOwner()

        emit NFTBurnt(owner)

        destroySelf!(owner)
    }

   fn checkCallerIsOwner() -> () {
       assert!(txCallerSize!() == 1)
       assert!(txCaller!(0) == owner)
    }
}
