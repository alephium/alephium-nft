Contract NFTListing(
    tokenId: ByteVec,
    tokenOwner: Address,
    marketContractId: ByteVec,
    commissionRate: U256,
    listingFee: U256,
    royalty: Bool,
    mut price: U256
) {

    enum ErrorCodes {
        MarketplaceAllowedOnly = 0
    }

    pub fn getTokenOwner() -> Address {
        return tokenOwner
    }

    pub fn getPrice() -> U256 {
        return price
    }

    pub fn getCommissionRate() -> U256 {
        return commissionRate
    }

    pub fn getListingFee() -> U256 {
        return listingFee
    }

    pub fn requiresRoyalty() -> Bool {
        return royalty
    }

    @using(preapprovedAssets = true, assetsInContract = true)
    pub fn buy(buyer: Address) -> () {
        checkCaller!(callerContractId!() == marketContractId, ErrorCodes.MarketplaceAllowedOnly)
        let marketPlace = NFTMarketPlace(marketContractId)
        let royaltyAmount = getRoyaltyAmount()
        let priceAfterFee = marketPlace.checkListingPriceAfterFee(price, commissionRate, listingFee, royaltyAmount)
        if (royaltyAmount > 0) {
            INFTCollectionWithRoyalty(NFT(tokenId).getCollectionId()).payRoyalty(royaltyAmount)
        }
        transferToken!(buyer, tokenOwner, ALPH, priceAfterFee)
        transferTokenFromSelf!(buyer, tokenId, 1)
        destroySelf!(tokenOwner)
    }

    @using(assetsInContract = true)
    pub fn cancel() -> () {
        checkCaller!(callerContractId!() == marketContractId, ErrorCodes.MarketplaceAllowedOnly)
        destroySelf!(tokenOwner)
    }

    @using(updateFields = true)
    pub fn updatePrice(newPrice: U256) -> () {
        checkCaller!(callerContractId!() == marketContractId, ErrorCodes.MarketplaceAllowedOnly)
        price = newPrice
    }

    @using(checkExternalCaller = false)
    pub fn getRoyaltyAmount() -> U256 {
        let marketPlace = NFTMarketPlace(marketContractId)
        return marketPlace.getRoyaltyAmount(tokenId, NFT(tokenId).getCollectionId(), price, royalty)
    }
}
