Contract NFTMarketPlace(
    nftListingTemplateId: ByteVec,
    mut admin: Address,
    mut listingFee: U256,
    mut commissionRate: U256   // basis point. e.g. 2.5% == 250 basis point
) {
    event NFTListed(
      price: U256,
      tokenId: ByteVec,
      tokenOwner: Address,
      listingContractId: ByteVec
    )

    event NFTSold(
      price: U256,
      tokenId: ByteVec,
      previousOwner: Address,
      newOwner: Address
    )

    event NFTListingCancelled(
      tokenId: ByteVec,
      tokenOwner: Address
    )

    event NFTListingPriceUpdated(
       tokenId: ByteVec,
       oldPrice: U256,
       newPrice: U256
    )

    event AdminUpdated(
        previous: Address,
        new: Address
    )

    event ListingFeeUpdated(
        previous: U256,
        new: U256
    )

    event CommissionRateUpdated(
        previous: U256,
        new: U256
    )

    enum ErrorCodes {
        AdminAllowedOnly = 0
        TokenOwnerAllowedOnly = 1
        NFTPriceTooLow = 2
    }

    @using(preapprovedAssets = true, assetsInContract = true, checkExternalCaller = false)
    pub fn buyNFT(
        tokenId: ByteVec
    ) -> () {
        let nftListingContractId = subContractId!(tokenId)
        let nftListing = NFTListing(nftListingContractId)
        let buyer = callerAddress!()
        let tokenOwner = nftListing.getTokenOwner()
        let price = nftListing.getPrice()
        let commissionRateOfListing = nftListing.getCommissionRate()
        let listingFeeOfListing = nftListing.getListingFee()
        let royaltyAmount = nftListing.getRoyaltyAmount()
        let priceAfterFee = checkListingPriceAfterFee(price, commissionRateOfListing, listingFeeOfListing, royaltyAmount)

        nftListing.buy{buyer -> ALPH: priceAfterFee}(buyer)

        // Charge a commission for the marketplace
        if (commissionRate > 0) {
            let commission = (price * commissionRateOfListing) / 10000
            transferToken!(buyer, selfAddress!(), ALPH, commission)
        }

        // Charge the listing fee
        transferTokenToSelf!(buyer, ALPH, listingFeeOfListing)

        emit NFTSold(price, tokenId, tokenOwner, buyer)
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn listNFT(
        tokenId: ByteVec,
        price: U256,
        royalty: Bool
    ) -> (Address) {
        let nftContract = NFT(tokenId)
        nftContract.validateCollectionId()
        let collectionId = nftContract.getCollectionId()
        let royaltyAmount = getRoyaltyAmount(tokenId, collectionId, price, royalty)

        checkListingPriceAfterFee(price, commissionRate, listingFee, royaltyAmount)

        // Only owner can list the NFT
        let tokenOwner = callerAddress!()

        let (encodeImmutableFields, encodeMutableFields) = NFTListing.encodeFields!(tokenId, tokenOwner, collectionId, selfContractId!(), commissionRate, listingFee, royalty, price)
        // Create the listing contract
        let nftListingContractId = copyCreateSubContract!{tokenOwner -> ALPH: 1 alph, tokenId: 1}(
            tokenId, nftListingTemplateId, encodeImmutableFields, encodeMutableFields
        )

        emit NFTListed(
            price,
            tokenId,
            tokenOwner,
            nftListingContractId
        )

        return contractIdToAddress!(nftListingContractId)
    }

    pub fn cancelNFTListing(tokenId: ByteVec) -> () {
        let nftListingContractId = subContractId!(tokenId)
        let nftListing = NFTListing(nftListingContractId)
        let tokenOwner = nftListing.getTokenOwner()

        checkCaller!(callerAddress!() == tokenOwner, ErrorCodes.TokenOwnerAllowedOnly)

        nftListing.cancel()
        emit NFTListingCancelled(tokenId, tokenOwner)
    }

    pub fn updateNFTPrice(tokenId: ByteVec, newPrice: U256) -> () {
        let nftListingContractId = subContractId!(tokenId)
        let nftListing = NFTListing(nftListingContractId)

        let commissionRateOfListing = nftListing.getCommissionRate()
        let listingFeeOfListing = nftListing.getListingFee()
        let royaltyAmount = nftListing.getRoyaltyAmount()

        checkListingPriceAfterFee(newPrice, commissionRateOfListing, listingFeeOfListing, royaltyAmount)
        checkCaller!(callerAddress!() == nftListing.getTokenOwner(), ErrorCodes.TokenOwnerAllowedOnly)

        let price = nftListing.getPrice()

        nftListing.updatePrice(newPrice)
        emit NFTListingPriceUpdated(tokenId, price, newPrice)
    }

    @using(updateFields = true)
    pub fn updateAdmin(newAdmin: Address) -> () {
        checkCaller!(callerAddress!() == admin, ErrorCodes.AdminAllowedOnly)

        admin = newAdmin
        emit AdminUpdated(admin, newAdmin)
    }

    @using(updateFields = true)
    pub fn updateListingFee(newListingFee: U256) -> () {
        checkCaller!(callerAddress!() == admin, ErrorCodes.AdminAllowedOnly)

        listingFee = newListingFee
        emit ListingFeeUpdated(listingFee, newListingFee)
    }

    @using(updateFields = true)
    pub fn updateCommissionRate(newCommissionRate: U256) -> () {
        checkCaller!(callerAddress!() == admin, ErrorCodes.AdminAllowedOnly)

        commissionRate = newCommissionRate
        emit CommissionRateUpdated(commissionRate, newCommissionRate)
    }

    pub fn getListingFee() -> U256 {
        return listingFee
    }

    @using(assetsInContract = true)
    pub fn withdraw(to: Address, amount: U256) -> () {
        checkCaller!(callerAddress!() == admin, ErrorCodes.AdminAllowedOnly)
        transferTokenFromSelf!(to, ALPH, amount)
    }

    pub fn checkListingPriceAfterFee(
        price: U256,
        commissionRateIn: U256,
        listingFeeIn: U256,
        royaltyAmount: U256
    ) -> U256 {
        let commission = (price * commissionRateIn) / 10000
        assert!(price > commission + listingFeeIn + royaltyAmount, ErrorCodes.NFTPriceTooLow)
        return price - commission - listingFeeIn - royaltyAmount
    }

    @using(checkExternalCaller = false)
    pub fn getRoyaltyAmount(
        tokenId: ByteVec,
        collectionId: ByteVec,
        price: U256,
        requiresRoyalty: Bool
    ) -> U256 {
        if (requiresRoyalty) {
            return INFTCollectionWithRoyalty(collectionId).royaltyAmount(tokenId, price)
        } else {
            return 0
        }
    }
}
