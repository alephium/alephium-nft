// The concept of a collection, which could contain different NFTs
// e.g. Bored Ape Yacht Club collection
Contract NFTCollection(
    nftTemplateId: ByteVec,
    mut currentTokenIndex: U256,
    @unused name: ByteVec,
    @unused symbol: ByteVec
) {
    event NFTMinted(
      minter: Address,
      collectionId: ByteVec,
      name: ByteVec,
      description: ByteVec,
      uri: ByteVec,
      tokenId: ByteVec,
      nftContractAddress: Address
    )

    enum ErrorCodes {
        IncorrectTokenIndex = 0
    }

    pub fn getName() -> ByteVec {
        return name
    }

    pub fn getSymbol() -> ByteVec {
        return symbol
    }

    // Lets say only 10000 NFTs
    pub fn totalSupply() -> U256 {
        return 10000
    }

    pub fn tokenIdByIndex(index: U256) -> ByteVec {
        assert!(index < totalSupply(), ErrorCodes.IncorrectTokenIndex)
        return subContractId!(toByteVec!(index))
    }

    @using(preapprovedAssets = true, updateFields = true)
    pub fn mint(
        nftName: ByteVec,
        nftDescription: ByteVec,
        nftUri: ByteVec
    ) -> (ByteVec) {
        let minter = callerAddress!()

        let collectionId = selfContractId!()

        let initialMutState = encodeToByteVec!(
            minter,
            true
        )

        let initialImmState = encodeToByteVec!(
            nftName,
            nftDescription,
            nftUri,
            collectionId
        )

        let contractId = copyCreateSubContractWithToken!{minter -> ALPH: 1 alph}(
            toByteVec!(currentTokenIndex),
            nftTemplateId,
            initialImmState,
            initialMutState,
            1,
            minter
        )

        currentTokenIndex = currentTokenIndex + 1

        emit NFTMinted(
            minter,
            collectionId,
            nftName,
            nftDescription,
            nftUri,
            contractId,
            contractIdToAddress!(contractId)
        )

        return contractId
    }
}