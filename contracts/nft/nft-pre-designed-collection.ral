// This is for the scenario where an artist or AI creates a set of arts
// in advance and sell to the public for minting
Contract NFTPreDesignedCollection(
    nftTemplateId: ByteVec,
    uri: ByteVec,
    baseUri: ByteVec,
    mut totalSupply: U256
) extends NFTCollectionBase(uri, totalSupply) {

    // TODO Add some comments
    @using(preapprovedAssets = true, updateFields = true)
    pub fn mint() -> (ByteVec) {
        let minter = callerAddress!()
        let nftUri = baseUri ++ u256ToString!(totalSupply)

        let initialImmState = encodeToByteVec!(selfContractId!(), nftUri)

        let contractId = copyCreateSubContractWithToken!{minter -> ALPH: 1 alph}(
            toByteVec!(totalSupply),
            nftTemplateId,
            initialImmState,
            #00,
            1,
            minter
        )

        totalSupply = totalSupply + 1
        return contractId
    }

    pub fn getTokenUri(index: U256) -> ByteVec {
        assert!(index < totalSupply, ErrorCodes.IncorrectTokenIndex)
        return baseUri ++ u256ToString!(index)
    }
}