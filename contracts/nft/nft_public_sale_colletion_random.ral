// This is for the scenario where an artist or AI creates a set of arts
// in advance and sell to the public for minting, users can mint any of
// the arts in the collection by paying the mint price.
Contract NFTPublicSaleCollectionRandom(
    enumerableNftTemplateId: ByteVec,
    collectionUri: ByteVec,
    collectionOwner: Address,
    nftBaseUri: ByteVec,
    maxSupply: U256,
    mintPrice: U256,
    mut totalSupply: U256
) extends NFTPublicSaleCollection(nftBaseUri, maxSupply) {
    enum ErrorCodes {
        IncorrectTokenIndex = 0
        NFTNotFound = 1
        TokenOwnerAllowedOnly = 2
    }

    @using(preapprovedAssets = true, updateFields = true, assetsInContract = true, checkExternalCaller = false)
    pub fn mint(index: U256) -> (ByteVec) {
        assert!(index < maxSupply, ErrorCodes.IncorrectTokenIndex)

        let minter = callerAddress!()
        let (encodeImmutableFields, encodeMutableFields) = EnumerableNFT.encodeFields!(selfContractId!(), getNFTUri(index), index)

        let contractId = copyCreateSubContractWithToken!{minter -> ALPH: 1 alph}(
            toByteVec!(index),
            enumerableNftTemplateId,
            encodeImmutableFields,
            encodeMutableFields,
            1,
            minter
        )

        transferTokenToSelf!(minter, ALPH, mintPrice)

        totalSupply = totalSupply + 1
        return contractId
    }

    @using(checkExternalCaller = false)
    pub fn nftByIndex(index: U256) -> NFTPublicSaleCollectionRandom {
        assert!(index < maxSupply, ErrorCodes.IncorrectTokenIndex)

        let nftTokenId = subContractId!(toByteVec!(index))
        assert!(contractExists!(nftTokenId), ErrorCodes.NFTNotFound)

        return NFTPublicSaleCollectionRandom(nftTokenId)
    }

    pub fn getCollectionUri() -> ByteVec {
        return collectionUri
    }

    pub fn totalSupply() -> U256 {
        return totalSupply
    }

    pub fn getCollectionOwner() -> Address {
        return collectionOwner
    }

    pub fn getMaxSupply() -> U256 {
        return maxSupply
    }

    pub fn getMintPrice() -> U256 {
        return mintPrice
    }

    @using(assetsInContract = true)
    pub fn withdraw(to: Address, amount: U256) -> () {
        checkCaller!(callerAddress!() == collectionOwner, ErrorCodes.TokenOwnerAllowedOnly)
        transferTokenFromSelf!(to, ALPH, amount)
    }
}
